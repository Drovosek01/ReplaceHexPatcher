# ReplaceHexPatcher - Документация

Language: Русский | [English](docs.md)

## Предисловие

Изначально я преследовал цель создать 2х-кликовое нативное для Windows решение для поиска и замены байт как это умеют делать утилиты `perl` и `sed` в macOS и GNU Linux.

То есть для решения поставленной задачи (поиска и замены байт) необходимо использовать только то что есть в Windows сразу после установки. Никаких сторонних файлов/программ скачиваться и применяться не должно.

В Windows предустановлены 3 "инструмента программирования" - CMD, Visual Basic Script, Powershell.
CMD слишком ограничен в возможностях. В Visual Basic Script я не нашел способа написать эффективный код для поиска и замены шаблона байт в файле любого объема. А вот Powershell это, очень грубо говоря, среда выполнения кода C#, а с помощью C# можно делать очень многие вещи и поэтому с помощью кода на Powershell вполне можно выполнить поиск и замену байт в hex формате.

Я начал искать способы сделать это на Powershell и сначала нашел [этот](https://stackoverflow.com/a/57339359) пример, но, если я правильно помню, такой поиск и замена байт работали у меня медленно. Других примеров я не смог найти и обратился к ChatGPT и он сгенерировал для меня необходимый скрипт. Я его протестировал и улучшил и написал дополнительные скрипты-обертки.

Конечно интерпретируемый код работает медленнее чем скомпилированные утилиты для данных задач, но, возможно если такие утилиты написанные на C# ([HexAndReplace](https://github.com/jjxtra/HexAndReplace) или [BinaryFilePatcher](https://github.com/Invertex/BinaryFilePatcher)) переписать на Powershell то это улучшит код и скорость его выполнения (но это не точно)

## Основа (Core)

Основу (ядро) данного инструмента составляет скрипт [ReplaceHexBytesAll.ps1](../core/ReplaceHexBytesAll.ps1) на Powershell, который находится в папке core. Он как раз и выполняет функцию поиска + замены байт и вывода небольшого отчета о том все ли шаблоны были заменены или какие-то шаблоны не найдены.

Он принимает 2 аргумента:
1. Путь к файлу в котором необходимо выполнить поиск и замену байт
2. Hex-шаблоны для поиска и замены байт в виде массива или 1 строкой

С путем к файлу все понятно, а вот шаблоны hex-байт можно предоставить в нескольких видах. В данном случае шаблон это строка разделенная 1 символом (`/` или `\` или `|`) на 2 части и первая часть это hex-байты для поиска, а вторая часть это hex-байты для замены.

Hex-байты можно передавать в разном формате - `AABBCC` или `A ABB CC` или `\xAAB BCC 1d` или `aabbcc`. В общем наличие или отсутствие пробелов, а также наличие или отсутствие символа `\x` (который обозначает 16-битное значение), а также регистр букв - не важны. Это все очистится и преобразуется к 1 формату.
Важно только чтобы паттерны содержали hex-символы (то есть все цифры `0-9` и буквы `a-f` включительно и без учета регистра).

Hex-шаблоны можно передавать как массив строк, так и в виде строки в которой содержится массив. 

Например вот так передается массив строк:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns "AABBCC/112233","44aa55\66bb77","1234|5678","E8A62600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"
```
А вот так передается строка с массивом
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns '"AABBCC/112233","44aa55\66bb77","1234|5678","E8A62600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"'
```
И потом это все распознается внутри скрипта и преобразуется в массив. Так сделано и для удобства и для возможности передачи шаблонов байт из другого Powershell-скрипта.

Попытки написать обертки над основным скриптом показали, что если из другого Powershell-скрипта запускать данный Powershell-скрипт от имени администратора то передавать аргументы в качестве массива не получится, поэтому пришлось делать дополнительную логику по обработке строки.

## Обертки (Wrappers)

Основной скрипт выполняет только поиск и замену байт в 1 файле. А что если необходимо сделать это для нескольких файлов?

Тогда поможет другой скрипт который будет выполнять основной скрипт передавая ему необходимые заранее сформированные аргументы - путь к файлу и необходимый массив паттернов, а также выполнять другие побочные эффекты:
- проверить наличие скрипта локально или скачать его по заготовленной ссылке
- проверять существование файлов которые необходимо модифицировать 
- завершать работу файла, который необходимо пропатчить, если он выполняется
- добавление строк в файл hosts (и проверка наличия этих строк, если они ранее были добавлены)
- блокировка `.exe` с помощью Windows Firewall
- создание файлов с заготовленным текстом
- удаление файлов и папок

и т.д.

Есть 2 типа скриптов-оберток:
1. Данные внутри скрипта (data inside)
2. Данные из шаблона (data in template)

### Обертка "data inside"

В первом типе скрипта все необходимые - пути или ссылки на "ядро", пути к файлам-целям для модификаций, все паттерны для поиска и замены, текст для hosts и для других файлов - все это находится внутри скрипта.

Для удобства внутрь скрипта добавлен чек-лист того что нужно проверить перед тем как считать его готовым.

1. Файлы-цели для патча
    - Если необходимо пропатчить несколько файлов (файлов-целей), то необходимо в переменную `count_target_files` вписать количество файлов для патча
    - Путь к каждому файлу поместить в переменные `target_path_1` и последняя цифра переменной должна быть уникальным последовательным индексом
2. Патчи - паттерны для поика+замены байт для файлов-целей
    - В переменную `count_patches_f1` необходимо вписать количество паттернов для поиска+замены байт. Последняя цифра в переменной означает индекс файла-цели для которого необходимо применить паттерны. Если файлов-целей несколько, то необходимо создать несколько таких переменных изменив индексы в их название на индексы соответствующие файлам-целям
    - Создать переменные `original_f1_1` и `patched_f1_1` в которых необходимо хранить hex-паттерны для поиска и замены байт соответственно. Для 1 hex-паттерна 1 переменная и если паттернов несколько - в новых переменных увеличить последнее число-индекс на 1. Текст `f1` означает индекс файла для которого предназначается паттерн
    - TODO: возможно лучше переделать скрипт, чтобы паттерны поиска+замены записывать не в разные переменные, а в 1 переменную, например `"pattern_f1_1=AABBCC/112233"`
3. Создание текстовых файлов
    - Если текстовые файлы создавать не нужно - закомментировать строку `call :create_all_text_files`
    - Если необходимо создать только 1 текстовый файл, то
      - в переменную `file_text_path_1` - поместить полный путь к текстовому файлу
      - в переменную `endline_text_file_1` вписать тип окончания строки (CRLF или LF)
      - в переменную `create_mode_text_file_1` вписать "режим создания" файла - FORCE или NOTOVERWRITE. При режиме FORCE файл будет перезаписан если такой файл существует, а при режиме NOTOVERWRITE файл не будет затронут/перезаписан, если он уже существует
      - внутри функции `:create_text_file_1` вписать текст который необходимо поместить в файл
    - Если необходимо создать несколько текстовых файлов, то создать несколько вышеперечисленных переменных под каждый файл и увеличить число-индекс в конце переменной
      - А также для каждого файла создать функцию `:create_text_file_1` с индивидуальным текстом для содержания файла (ну и число-индекс в названии функции тоже увеличить)
4. Добавление строк в hosts
    - Если в файл hosts ничего не нужно добавлять - закомментировать строку `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"`
    - Если в файл hosts нужно добавить какие-то строки, то сами URL-адреса для блокировки добавить внутрь функции `:block_hosts`, при выполнении скрипта функция сама сформирует строки и добавит их в hosts, если таких строк раньше не было
      - Также в строку вызова функции `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"` первым аргументом добавить слово "FORCE" или "NOTOVERWRITE". "FORCE" означает тупо добавить строки в конец hosts, а "NOTOVERWRITE" означает не добавлять их если точно такой же набор строк с таким же названием группы есть в конце файла
      - Ну а вместо "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS" написать название/заголовок для группы строк, например "Adobe servers"
5. Блокировка файлов-целей с помощью Windows Firewall
    - Если файлы-цели не нужно блокировать с помощью фаервола, то закомментировать строку `call :block_targets_with_firewall`, иначе оставить эту строку без изменений

Возможно было бы логичнее часть функционала вынести в отдельные файлы-скрипты, но я хотел сделать максимально "монолитное" 2-кликовое решение. 


### Обертка "data in template"

Во втором типе скрипта все данные для работы берутся из файла `template.txt`

## Небольшие личные выводы

### CMD это боль

И вот почему:
- нет нормальных функций
  - конструкции `call` необходимо обязательно помещать в конце файла, иначе при выполнении кода эти блоки также будут прочитаны и выполнены, они никак не огорожены, просто на них есть "ссылка" 
- нет нормальных циклов
  - чтобы сделать циклы необходимо делать условия в которых есть `goto` на метку вне/перед условием
- повторное оборачивание чего-либо в кавычки - добавляет эти кавычки в оборачиваемое значение и из-за этого часто возникают проблемы и это приходится держать в голове
- нет нормального способа хранить любой многострочный текст
  - если в многострочном тексте нет кавычек и некоторых спец. символов, то такой текст можно хранить в многострочном виде, но если есть кавычки и спец. символы то приходится перед каждой строкой добавлять `echo `

Основной плюс из-за которого стоит рассматривать написание чего-либо на CMD - это то, что его можно запустить 2-м кликом в любой Windows. (Конечно есть еще VBS но он как-то менее распространен)

### Адаптивный перезапуск с правами админа (UAC) - это очень большой геморрой

Если делать утилиту "по феншую", то права администратора необходимо запрашивать только когда без них точно не обойтись.

Также стоит помнить про атрибут "только для чтения", потому что если у файла стандартные права то этот атрибут можно снять без проблем без запроса прав администратора, хотя тест на попытку записи покажет что нужны права админа для изменения файла.

Жонглирование этими 2мя пунктами "права администратора" и атрибут "только для чтения" довольно запутанная задача и это добавляет довольно много дополнительной логики в скрипт и уменьшает читаемость кода.

Особенно это является проблемой когда из обычного Powershell-скрипта необходимо запустить код который содержит многострочный текст.

Намного проще и удобнее запросить права администратора в самом начале выполнения скрипта и прервать выполнение при их отсутствие, но не факт что эти права действительно необходимы для внесения изменений.

True-путь это запрашивать права при необходимости.