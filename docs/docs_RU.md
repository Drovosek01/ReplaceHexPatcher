# ReplaceHexPatcher - Документация

Language: Русский | [English](docs.md)

## Предисловие

Изначально я преследовал цель создать 2х-кликовое нативное для Windows решение для поиска и замены байт как это умеют делать утилиты `perl` и `sed` в macOS и GNU Linux.

То есть для решения поставленной задачи (поиска и замены байт) необходимо использовать только то что есть в Windows сразу после установки. Никаких сторонних файлов/программ скачиваться и применяться не должно.

В Windows предустановлены 3 "инструмента программирования" - CMD, Visual Basic Script, Powershell.
CMD слишком ограничен в возможностях. В Visual Basic Script я не нашел способа написать эффективный код для поиска и замены шаблона байт в файле любого объема. А вот Powershell это, очень грубо говоря, среда выполнения кода C#, а с помощью C# можно делать очень многие вещи и поэтому с помощью кода на Powershell вполне можно выполнить поиск и замену байт в hex формате.

Я начал искать способы сделать это на Powershell и сначала нашел [этот](https://stackoverflow.com/a/57339359) пример, но, если я правильно помню, такой поиск и замена байт работали у меня медленно. Других примеров я не смог найти и обратился к ChatGPT и он сгенерировал для меня необходимый скрипт. Я его протестировал и улучшил и написал дополнительные скрипты-обертки.

Конечно интерпретируемый код работает медленнее чем скомпилированные утилиты для данных задач, но, возможно если такие утилиты написанные на C# ([HexAndReplace](https://github.com/jjxtra/HexAndReplace) или [BinaryFilePatcher](https://github.com/Invertex/BinaryFilePatcher)) переписать на Powershell то это улучшит код и скорость его выполнения (но это не точно)

## Основа (Core)

Основу (ядро) данного инструмента составляет Powershell-скрипт [ReplaceHexBytesAll.ps1](../core/ReplaceHexBytesAll.ps1), который находится в папке "core". Он как раз и выполняет функцию поиска + замены байт и вывода небольшого отчета о том все ли шаблоны были заменены или какие-то шаблоны не найдены.

Он принимает 3 аргумента:
1. Путь к файлу в котором необходимо выполнить поиск и замену байт, указывается после аргумента `-filePath`
2. Hex-шаблоны для поиска и замены байт в виде массива или 1 строкой, указывается после аргумента `-patterns`
3. Параметр `-makeBackup` если необходимо создать бэкап оригинального файла

Подробнее:

1. Путь к файлу

С путем к файлу все очевидно. Путь к файлу-цели в котором будет производится поиск и замена байт. Если ни один паттерн байт не будет найден файл не будет никак затронут.

Путь к файлу передается как аргумент запуска скрипта `-filePath "D:\path\to\file.exe"`

2. Hex-паттерны

Шаблоны для поиска + замены байт в hex-формате. Паттерны для поиска и паттерны для замены байт пишутся в 1 строке и разделаются одним из символов `/` или `\` или `|`.

Важно только чтобы паттерны содержали hex-символы (то есть состояли из цифр `0-9` и букв `a-f` включительно и без учета регистра).
Сами паттерны не имеют строго формата. Между значениями в паттерне может быть любое количество пробелов и символов `\x` - все они удалятся (их наличие не вызовет ошибок). То есть все эти форматы валидные - `AABBСС/112233`, `AA    BB CC/1 122 3 3`, `\xAA\xBB \xCC/1122\x33`

Все наборы паттернов передаются после указания аргумента запуска скрипта `-patterns`.
Их можно передавать как массив строк через запятую `"AABB/1122","CCDD/4455"`, так и в виде 1 большой строки `"AABB/1122,CCDD/4455"`. Такая вариативность сделана в первую очередь потому что если запускать скрипт из другого Powershell-скрипта через `Start-Process`, то передаваемые через запятую строки не распознаются как массив.

3. Бэкап патченного файла

Передав параметр `-makeBackup` оригинальный файл (цель) будет скопирован в ту же папку где он находился и к его полному имени будет добавлен текст `.bak`. Атрибут "Только чтение" у файла будет сохранен, как и разрешения и параметры NTFS.

Бэкап будет сделан только если у файла будет найден хотя бы один паттерн.
Если паттерны найдены не будут, соответственно цель никак не будет изменена и в бэкапе нет смысла.

Чтобы воспользоваться скриптом, необходимо:
1. Запустить Powershell
2. С помощью `cd <путь>` перейти в папку с файлом `ReplaceHexBytesAll.ps1`
3. В окне Powershell выполнить:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\file.exe" -patterns "48 83EC2 8BA2F 000000 488A/202 0EB1 1111 11111 111111","C42518488D4D68\90909011111175","45A8488D55A8|75EB88909090","\xAA\x7F\xBB\x08\xE3\x4D|\xBB\x90\xB1\xE8\x99\x4D" -makeBackup
```

Вот другие примеры валидных команд:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns "AABBCC/112233","44aa55\66bb77","1234|5678","E8A62600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"
```

```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\file.exe" -patterns "4883EC28BA2F000000488A/2020EB1 111111111111111,C42518488D4D68/90909011111175,45A8488D55A8/75EB88909090,AA7FBB08E34D/BB90B1E8994D"
```


## Обертки (Wrappers)

Основной скрипт выполняет только поиск и замену байт в 1 файле. А что если необходимо сделать это для нескольких файлов? А также создать один или несколько файлов с текстом или заблокировать к файлам доступ в сеть с помощью фаервола?

Все эти дополнительные действия (сайдэффекты) можно сделать с помощью дополнительного кода, который я написал в отдельных скриптах. Эти скрипты формируют команды для запуска основного скрипта-патчер с динамически сформированными аргументами, а также выполняют дополнительные действия.

Есть 2 типа скриптов-оберток:
1. Данные внутри скрипта (data inside)
2. Данные из шаблона (data in template)


### Скрипт-обертка "data inside"

Этот скрипт написан на CMD с небольшим добавлением Powershell кода там где без него не обойтись. В этом типе скрипта все необходимые - пути или ссылки на "ядро", пути к файлам-целям для модификаций, все паттерны для поиска и замены, текст для hosts и для других файлов - все это находится внутри скрипта `Start.cmd`

Прежде чем запускать скрипт - его нужно настроить. Нужно внести данные с которыми он будет работать - добавить паттерны, пути к файлам для модификаций и т.д. - все это вручную с помощью изменения существующих переменных и добавления новых переменных.
Я старался написать скрипт так, чтобы добавление и изменение этих переменных было простым действием и делалось в минимальном количестве мест в коде (только в блоке кода "MAIN").

Для удобства внутрь скрипта добавлен чек-лист того что нужно проверить перед тем как считать его готовым.

1. Файлы-цели для патча
    - Если необходимо пропатчить несколько файлов (файлов-целей), то необходимо в переменную `count_target_files` вписать количество файлов для патча
    - Путь к каждому файлу поместить в переменные `target_path_1` и последняя цифра переменной должна быть уникальным последовательным индексом
2. Патчи - паттерны для поика+замены байт для файлов-целей
    - В переменную `count_patches_f1` необходимо вписать количество паттернов для поиска+замены байт. Последняя цифра в переменной означает индекс файла-цели для которого необходимо применить паттерны. Если файлов-целей несколько, то необходимо создать несколько таких переменных изменив индексы в их название на индексы соответствующие файлам-целям
    - Создать переменные `original_f1_1` и `patched_f1_1` в которых необходимо хранить hex-паттерны для поиска и замены байт соответственно. Для 1 hex-паттерна 1 переменная и если паттернов несколько - в новых переменных увеличить последнее число-индекс на 1. Текст `f1` означает индекс файла для которого предназначается паттерн
    - TODO: возможно лучше переделать скрипт, чтобы паттерны поиска+замены записывать не в разные переменные, а в 1 переменную, например `"pattern_f1_1=AABBCC/112233"`
3. Создание текстовых файлов
    - Если текстовые файлы создавать не нужно - закомментировать строку `call :create_all_text_files`
    - Если необходимо создать только 1 текстовый файл, то
      - в переменную `file_text_path_1` - поместить полный путь к текстовому файлу
      - в переменную `endline_text_file_1` вписать тип окончания строки (CRLF или LF)
      - в переменную `create_mode_text_file_1` вписать "режим создания" файла - FORCE или NOTOVERWRITE. При режиме FORCE файл будет перезаписан если такой файл существует, а при режиме NOTOVERWRITE файл не будет затронут/перезаписан, если он уже существует
      - внутри функции `:create_text_file_1` вписать текст который необходимо поместить в файл
    - Если необходимо создать несколько текстовых файлов, то создать несколько вышеперечисленных переменных под каждый файл и увеличить число-индекс в конце переменной
      - А также для каждого файла создать функцию `:create_text_file_1` с индивидуальным текстом для содержания файла (ну и число-индекс в названии функции тоже увеличить)
4. Добавление строк в hosts
    - Если в файл hosts ничего не нужно добавлять - закомментировать строку `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"`
    - Если в файл hosts нужно добавить какие-то строки, то сами URL-адреса для блокировки добавить внутрь функции `:block_hosts`, при выполнении скрипта функция сама сформирует строки и добавит их в hosts, если таких строк раньше не было
      - Также в строку вызова функции `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"` первым аргументом добавить слово "FORCE" или "NOTOVERWRITE". "FORCE" означает тупо добавить строки в конец hosts, а "NOTOVERWRITE" означает не добавлять их если точно такой же набор строк с таким же названием группы есть в конце файла
      - Ну а вместо "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS" написать название/заголовок для группы строк, например "Adobe servers"
5. Блокировка файлов-целей с помощью Windows Firewall
    - Если файлы-цели не нужно блокировать с помощью фаервола, то закомментировать строку `call :block_targets_with_firewall`, иначе оставить эту строку без изменений

Возможно было бы логичнее часть функционала вынести в отдельные файлы-скрипты, но я хотел сделать максимально "монолитное" 2-кликовое решение. 


### Скрипт-обертка "data in template"

Во втором решении лезть внутрь скрипта не нужно, все данные для работы берутся из файла `template.txt`. Этот шаблон парсит соответствующий скрипт `Parser.ps1` и при наличии блока с путями + паттернами - вызывает скрипт `ReplaceHexBytesAll.ps1` с динамически сформированными аргументами. Также скрипт-парсер выполняет дополнительные действия в зависимости от наполнения файла `template.txt` - добавляет или удаляет строки из `hosts`, добавляет или удаляет файлы и т.д.

Парсер принимает 2 аргумента - `-templatePath <строка>` и `-patcherPath <строка>`. С каждым аргументом необходимо указать путь к файлу или URL. Аргумент `patcherPath` указывать не обязательно, потому что путь/URL к патчеру можно написать также в `template.txt`, но если аргумент `-patcherPath` передан то он будет первым в очереди на проверку путей к патчеру (относительно путей из template).

Вот пример запуска парсера из Powershell:
```
.\Parser.ps1 -templatePath "C\Users\Public\template.txt" -patcherPath "C:\Users\Public\ReplaceHexBytesAll.ps1"
```

В той же папке есть `Start.cmd` - это обертка над `Parser.ps1` чтобы парсер можно было запустить двойным кликом, а не открывать сначала Powershell и переходить в папку с парсером.
В этом скрипте-обертке можно заранее указать полный путь (или URL) к парсеру и к `template.txt` и к патчеру в соответствущих переменных `parser_path`, `template_path`, `patcher_path` и тогда парсер запустится вместе с этими аргументами.

Если пути (или URL) не указать, тогда будет производится сначала поиск парсера (файла с именем `Parser.ps1`) сначала в текущей папке, если там его не будет то парсер будет скачан по прямой ссылке из текущего репозитория и путь к скачанному файлу и будет являться путем к парсеру.
Потом такая же процедура поиска будет по отношению к файлу `template.txt`. А к путь (или URL) к патчеру нужно указывать вручную, иначе он не будет передан (и будут использованы пути из файла-шаблона).

#### Шаблон template.txt

Теперь о шаблоне. Структура шаблона была сделана так, чтобы данные можно было легко заполнять вручную обычным Ctrl+C и Ctrl+V, поэтому шаблоны данных в формате `.json` и `.xml` не подходят, потому что при их заполнении легко ошибиться и нарушить структуру.

**Структура шаблона:**

1. Секции (блоки с строками/данными)
   1. В шаблоне могут располагаться разные данные и каждый тип данных должен располагаться в своей секции. Секции отделяются строками, которые содержат следующий текст
       - `[start-НАЗВАНИЕ_СЕКЦИИ]` - строка начало секции
       - `[end-НАЗВАНИЕ_СЕКЦИИ]` - строка конец секции
       - все что между этими строками (то есть внутри секции) - данные секции и будут анализироваться парсером в зависимости от названия секции
       - все что не внутри какой-либо секции - не будет никак анализироваться, по сути можно считать это комментариями к шаблону и секциям и вну секций можно писать все что угодно
       - секции могут быть расположены в любой последовательности, это не повлияет на очередность их анализа. Очередность задана в области MAIN в парсере
   2. Есть во такие секции, подробнее о каждой будет дальше
       - `patcher_path_or_url`
       - `variables`
       - `targets_and_patterns`
       - `file_create_from_text`
       - `file_create_from_base64`
       - `hosts_add`
       - `hosts_remove`
       - `files_or_folders_delete`
       - `firewall_block`
       - `firewall_remove_block`
       - `registry_file`
       - `powershell_code`
       - `cmd_code`
2. Комментарии
    - Все что не внутри какой-либо секции - не будет никак анализироваться, по сути можно считать это комментариями к шаблону и секциям и вну секций можно писать все что угодно
    - Внутри секций тоже могут быть комментарии. Все строки содержащие этот текст `;;` - считаются комментариями и будут удалены перед дальнейшим анализом
3. Глобальные переменные
    - Текст `$USER` будет заменен на имя текущего пользователя Windows везде в шаблоне

**Последовательность действия в парсере**
1. Поиск и замена всех глобальных переменных в шаблоне
2. Проверка наличия секций `hosts_remove`, `hosts_add`, `firewall_block`, `firewall_remove_block`, `registry_file`. Если такие секции есть и парсер запущен не от имени Администратора - перезапускаем парсер с полученными аргументами от имени Администратора, потому что при использовании данных из этих секций 100% понадобятся права админа и чтобы при обработке данных из каждой секции не запрашивать эти права в отдельных процессах - удобнее перезапустить скрипт с нужными правами с самого начала.
3. Поиск секций и извлечение данных из них в такой очередности
    1. `variables`
    2. `patcher_path_or_url`
    3. `targets_and_patterns`
    4. `hosts_remove`
    5. `hosts_add`
    6. `files_or_folders_delete`
    7. `file_create_from_text`
    8. `file_create_from_base64`
    9. `firewall_remove_block`
    10. `firewall_block`
    11. `registry_file`
    12. `powershell_code`
    13. `cmd_code`
4. Будет использована первая найденная секция каждого типа, если у одного типа (например `hosts_add`) несколько секций в шаблоне - все последующие секции этого типа, кроме первой сверху - не будут использоваться.
    - Исключением являются секции `file_create_from_text` и `file_create_from_base64`, потому что при необходимости создания нескольких файлов - необходимо разместить несколько таких секций
5. При использовании данных извлеченных из каждой секции производится сначала "очистка" данных - `Trim()` по для блока с всем текстом секции, а потом поиск и замена переменных из секции `variables`
    - Исключением являются секции `file_create_from_text` и `file_create_from_base64` - для них производится не `Trim()`, а `TrimStart()`, то есть удаление "пустот" вначале текста. Это сделано для того, чтобы если в создаваемом тексте должны быть пустые строки в конце - чтобы они не удалились из контента секции
    - Все окончания строк извлеченного из шаблона текста приводятся к типу `LF`, то есть `\n` для удобства обработки. Это не влияет на тип окончания строк в создаваемых файлах, потому что это значение можно задать вручную в соответствующих секциях 
6. Далее в зависимости от типа секции данных используются соответствующим образом (об этом подробнее в информации о каждой секции)
7. Если скрипт не имеет права Администратора, но для совершения действий требуются права Администратора - будет сформирована Powershell-команда и запущена в отдельном процессе с запросом прав админа
    - Исключением являются секции `firewall_remove_block` и `firewall_block` - если не будет прав администратора они выдадут ошибки
8. В каждой секции данные считываются и обрабатываются построчно
9. После работы парсера удаляются все временные файлы, отображается длительность работы парсера и строка `Press any key to continue...`, далее нажав на любую клавишу он закрывается.

**Секции (блоки с строками/данными)**

1. `variables`

Здесь можно задать переменные, если какой-то кусок текста (например паттерн или путь к файлу) дальше в шаблоне нужно использовать несколько раз. Каждая новая переменная пишется с новой строки, сначала название переменной, потом знак `=`, потом данные привязанные к переменной.

Пример
`path_to_prog = C:\Users\Public\some folder again\program.exe`

Потом строка делится на 2 части по знаку `=` и производится `Trim()` обеих частей и далее в каждой секции будет производится поиск и замена имени переменной на ее значение. Поэтому указывайте имя уникальное для всего текста в шаблоне.

2. `patcher_path_or_url`

Здесь на каждой строке указывается путь на диске к скрипту-патчеру, либо URL для его скачивания. Проверяется каждая строка и если строка - путь к существующему файлу на диске, то это и возвращается как путь к патчеру. Если строка это `http*` ссылка на файл - проверяется доступность ссылки и скачивается файл по ней в временную папку пользователя и возвращается путь к этому файлу из временной папки, а также флаг что файл временный (для последующего удаления после того как парсер завершит работу с шаблоном). Получается можно указать несколько ссылок на парсер, на случай если какая-то из них не будет работать.

Ошибка будет только в случае если среди всех строк не окажется пути к существующему файлу на диске или URL-адрес не будет доступен для скачивания данных. Если будут строки с каким-то текстом который не является путем к файлу или ссылкой - эти строки просто проигнорируются.

3. `targets_and_patterns`

Здесь располагаются пути к файлам и паттерны для для поиска + замены файлов. Сначала идет строка - абсолютный путь к файлу. Следующие строки - паттерны для поиска+замены байт. Строки-паттерны могут быть как отдельная строка с байтами для поиска и отдельная строка для замены, либо строка может содержать оба паттерна, но они должны разделяться тем же самым разделителем, который используется при передаче паттернов в качестве аргументов к `ReplaceHexBytesAll.ps1`.
В общем сначала идет поиск строки - пути к файлу, а все следующие строки анализируются как hex-паттерны пока не будет найдена очередная строка - путь к файлу.

Ну и не забывайте что все эти данные (пути к файлам и паттерны) могут хранится в переменных и тут могут быть написаны только переменные.

4. `hosts_remove`

Здесь указываются строки или URL-адреса которые должны быть удалены из файла `hosts`. Если строка секции начинается с символа комментария `#` или с `127.0.0.1` или с `0.0.0.0`, то будет производится поиск точно такой же строки, без учета длины пробелов. В противном случае предполагается что указан URL-адрес (например adobe.io), и строки содержащие такой адрес (такое слово, то есть текст и границами текста будут пробелы или переносы строк) будут удалены.

При это можно указывать символ звездочки `*` и это будет значит регулярное выражение `.*` (до границ слова). То есть можно в секции написать строку с `*adobe*` и это приведен к удалению всех строк в которых содержится слово `adobe` с любыми символами, но если в секции будет строка `adobe` без звезд, то будут удалены строки которые содержат именно это слово без каких либо добавочных символов. Либо можно также указать `*adobe.io` и это удалит все строки с под доменами `adobe.io`

5. `hosts_add`

Здесь указываются строки которые необходимо добавить в файл `hosts`. Обычно добавляются строки, чтобы заблокировать доступ к каким-то URL-адресам, поэтому в этой секции можно просто написать URL-адреса (разумеется каждый на новой строке) и в `hosts` будет добавлена строка `0.0.0.0 <URL-адрес>` и это будет блокировать доступ к URL-адресу.

Если строка в секции начинается с `127.0.0.1` или с символа комментария `#`, то она будет добавлена в hosts без изменений. В противном случае строка считается непосредственным URL-адресом (например adobe.com) и в ее начало будет добавлено `0.0.0.0 ` что приведет к блокировке URL-адреса.

Функция по работе с этой секцией действует грамотно - если файла `hosts` не существует, то он будет создан. Если есть атрибут "Только чтение" то он будет снят перед изменение файла, а потом атрибут будет снова установлен. Если у скрипта нет прав Администратора для изменения файла - будет сформирована отдельная команда с текстом для добавления в `hosts` и она запустится в отдельном процессе Powershell с запросом прав админа.

Для этой секции есть "флаг" (индикатор/переключатель) - фраза `NOT MODIFY IT`. Если эта фраза будет в самом начале секции - все строки будут добавлены в `hosts` без изменений. Только `Trim()` будет применяться к строкам.

6. `files_or_folders_delete`

Здесь указываются абсолютные пути к файлам и папкам которые необходимо удалить.

Функция по работе с этой секцией действует грамотно - если у файла есть атрибут "Только чтение" то он будет снят перед удалением, чтобы не было ошибок. Если для удаления каких-то файлов или папок нужны будут права администратора - все они будут сформированы в отдельный внутренний список и будет запущен отдельный Powershell процесс с запросом прав администратора который удалит все эти файлы и папки.

Для этой секции есть "флаг" (индикатор/переключатель) - фраза `MOVE TO BIN`. Если эта фраза будет в самом начале секции - все файлы и папки будут перемещаться в Корзину, а не удаляться из системы.

7. `file_create_from_text`

Здесь указываются данные для создания текстового файла. Первая строка секции - путь к файлу который необходимо создать и наполнить данными. Вторая строка может быть либо "флагом" (смотрите здесь ниже) либо уже началом текста который необходимо поместить в созданный файл. Если такой файл уже существует - сперва он будет удален. Далее идут строки с текстом которые будут помещены в созданный файл. Пустые строки не будут удаляться.

Для этой секции есть "флаг" (индикатор/переключатель) - фраза `CRLF`, либо `LF`. Если эта фраза будет во второй строке секции - это определит тип окончания строк в созданном текстовом файле. Если этого "флага" не будет, тип окончания строк будет такой же который используется при работе с текстом внутри скрипта, то есть `LF`.

8. `file_create_from_base64`

Здесь указываются данные для создания файла на основе расшифрованного base64 кода. Первая строка секции - путь к файлу который необходимо создать и наполнить данными. Вторая строка может быть либо "флагом" (смотрите здесь ниже) либо уже началом данных которые необходимо поместить в созданный файл. Если такой файл уже существует - сперва он будет удален. Далее идут строки с 1 большим base64-кодом и этот код будет расшифрован и его содержимое помещено в файл. Код может быть расшифрован в текстовый файл, а может быть расшифрован в бинарный файл, за это отвечает соответствующий "флаг" `BINARY DATA`.

Для этой секции есть "флаги" (индикаторы/переключатели) - фраза `CRLF`, либо `LF`, а также `BINARY DATA`. Все флаги должны находится во второй строке секции. Если там будет фраза `CRLF`, либо `LF` - это определит тип окончания строк в созданном текстовом файле и даже если в расшифрованном base64-коде тип окончания строк будет другой - тип окончания строк будет конвертирован. Если этого "флага" не будет, тип окончания строк никак не будет изменен. Наличие флага `BINARY DATA` будет означать что в расшифрованном base64-коде нет текста и код надо расшифровывать в байты и записывать в файл без представления байт в виде текста.

9. `firewall_remove_block`

Здесь указываются абсолютные пути к файлам (очевидно это должны быть `.exe`-файлы) которые необходимо удалить из Windows Firewall. Предполагается что это будет выполняться для разблокировки доступа в интернет для программ для которых ранее доступ в есть был заблокирован.Будут удалены все правила фаервола для указанных путей, хотя, возможно, стоит добавить какие-либо параметры чтобы удалялись правила только блокирующие доступ в интернет.

Если необходимо применить удаление правил ко всем `.exe`-файлам в какой-то папке и всех вложенных папках, можно указать путь к этой папке и в конце путь должен заканчиваться текстом `\*`. Если необходимо сделать тоже самое но без вложенных папок, а только для 1 указанной папки, то путь должен заканчиваться `\*.exe`.

Для изменения параметров Windows Firewall однозначно нужны права администратора и если по каким-то причинам при работе этой функции этих прав у скрипта не будет - будет ошибка.

10. `firewall_block`

Здесь указываются абсолютные пути к файлам (очевидно это должны быть `.exe`-файлы) которым необходимо заблокировать доступ в сеть с помощью Windows Firewall.

Если необходимо заблокировать доступ к всем `.exe`-файлам в какой-то папке и всех вложенных папках, можно указать путь к этой папке и в конце путь должен заканчиваться текстом `\*`. Если необходимо сделать тоже самое но без вложенных папок, а только для 1 указанной папки, то путь должен заканчиваться `\*.exe`.

Для изменения параметров Windows Firewall однозначно нужны права администратора и если по каким-то причинам при работе этой функции этих прав у скрипта не будет - будет ошибка.

11. `registry_file`

Здесь указываются данные для модификации Windows Реестра. Абсолютно те же самые строки что пишутся в файлах `.reg` можно (нужно) писать здесь.

"Заголовок" в виде первой строки `Windows Registry Editor Version 5.00` можно не писать, он будет добавлен динамически, если его не будет в начале секции.

Если скрипт будет запущен без прав Администратора, то во временной папке будет создан файл `.reg` в который будут записаны эти данные. Потом будет запущен отдельный процесс Powershell с запросом прав администратора и в этом процессе выполнится команда импорта данных из этого файла в реестр Windows.

12. `powershell_code`

Здесь указывается код который будет помещен в отдельный файл `.ps1` и будет запущен. У функции, обрабатывающей эту секцию есть параметры `-hideExternalOutput` и `-needRunAS`. Добавив параметр `-hideExternalOutput` - весь стандартный поток вывода будет перенаправляться в `$null` (это сделано если вложенный скрипт имеет много текста для вывода в окно терминала и нужно скрыть этот текст), а параметр `-needRunAS` запускает этот скрипт с запросом прав Администратора. Если скрипт не будет перезапускаться с правами админа в отдельном процессе то результаты его работы будут выводится в текущем окне Powershell.

Текст из данной секции также подвергается анализу и замене переменных на их значения из секции переменных.

13. `cmd_code`

Здесь указывается код который будет помещен в отдельный файл `.cmd` и будет запущен. У функции, обрабатывающей эту секцию есть параметры `-hideExternalOutput` и `-needRunAS` и `-needNewWindow`.  Добавив параметр `-hideExternalOutput` - весь стандартный поток вывода будет перенаправляться в `$null` (это сделано если вложенный скрипт имеет много текста для вывода в окно терминала и нужно скрыть этот текст), а параметр `-needRunAS` запускает этот скрипт с запросом прав Администратора, а параметр `-needNewWindow` запускает скрипт в новом окне.

При этом если есть параметр `-needRunAS` и текущий скрипт-парсер не имеет прав админа, то созданный `.cmd`-скрипт в любом случае будет запущен в новом окне для запроса прав Администратора.

Текст из данной секции также подвергается анализу и замене переменных на их значения из секции переменных.


## Небольшие личные выводы

Это мой первый опыт написания скриптов на CMD (batch) и Powershell. Учитывайте это при чтении моих выводов.

### О CMD

**CMD это боль!**

И вот почему:
- нет нормальных функций
  - конструкции `call` необходимо обязательно помещать в конце файла, иначе при выполнении кода эти блоки также будут прочитаны и выполнены, они никак не огорожены, просто на них есть "ссылка" 
- нет нормальных циклов
  - чтобы сделать циклы необходимо делать условия в которых есть `goto` на метку вне/перед условием
- повторное оборачивание чего-либо в кавычки - добавляет эти кавычки в оборачиваемое значение и из-за этого часто возникают проблемы и это приходится держать в голове
- нет нормального способа хранить любой многострочный текст
  - если в многострочном тексте нет кавычек и некоторых спец. символов, то такой текст можно хранить в многострочном виде, но если есть кавычки и спец. символы то приходится перед каждой строкой добавлять `echo `

Основной плюс из-за которого стоит рассматривать написание чего-либо на CMD - это то, что его можно запустить 2-м кликом в любой Windows. (Конечно есть еще VBS но он как-то менее распространен)

### Адаптивный перезапуск с правами админа (UAC) - это очень большой геморрой

Если делать утилиту "по феншую", то права администратора необходимо запрашивать только когда без них точно не обойтись.

Также стоит помнить про атрибут "только для чтения", потому что если у файла стандартные права то этот атрибут можно снять без проблем без запроса прав администратора, хотя тест на попытку записи покажет что нужны права админа для изменения файла.

Жонглирование этими 2мя пунктами "права администратора" и атрибут "только для чтения" довольно запутанная задача и это добавляет довольно много дополнительной логики в скрипт и уменьшает читаемость кода.

Особенно это является проблемой когда из обычного Powershell-скрипта необходимо запустить код который содержит многострочный текст.

Намного проще и удобнее запросить права администратора в самом начале выполнения скрипта и прервать выполнение при их отсутствие, но не факт что эти права действительно необходимы для внесения изменений.

True-путь это запрашивать права при необходимости.

### О Powershell

Powershell показал себя с хорошей стороны и является хорошей альтернативой Unix Shell.

Естественно, сравнивать CMD и Powershell это тупо, это совсем разные "уровни", это как сравнивать небо и землю.

Но без недостатков не обошлось. И вот какие они:
- `.ps1` скрипты нельзя запустить двойным кликом, в отличие от Unix Shell-скриптов в Unix-системах и в отличие от `.cmd` или `.bat` или `.vbs` файлов в Windows. Придется писать скрипт-обертку `.cmd` для запуска `.ps1`, если нужен запуск по двойному клику.
- Типизация фиктивная - интерпретатор нигде не проверяет соответствие переменной указанному ей типу. Похоже типизация применяется только в IDE для авто дополнения.
- Нет хороших IDE (я не нашел).
  - Windows Powershell ISE - выглядит старомодно и топорно и лично мне в ней не комфортно писать большой код и нет множества удобных функций, по сравнению с Visual Studio Code.
  - Visual Studio Code по началу казалась безупречной альтернативой "ISE" для написания кода Powershell, но в VSC почему-то авто дополнение работает странно (или не работает совсем) в некоторых моментах - когда начинаю набирать слова `break` или `continue` то автодополнение не подсказывает продолжение этих слов, значит есть и другие аналогичные ситуации.
  - Может в IDE от JetBrains все идеально при написании кода на Powershell, но я это не проверял.
- Возврат значения в "никуда" в самом скрипте - вернет значение в поток вывода.
  - Это немного странное поведение и если о нем не знать или забыть учесть этот нюанс - можно потратить много времени на дебаг. А именно при выполнении функций `New-Item` и функции `.Add()` у `ArrayList` - эти функции возвращают значение. Если [не присвоить](https://stackoverflow.com/a/46586504) то значение - оно попадет в поток вывода, то есть смешается с тем что будет передаваться в `Write-Host`.
- Есть странная ситуация при которой производительность скрипта падает в 3 раза (он работает в 3 раза дольше)
  - Я пытался отрефакторить одну функцию и вынес инициализацию переменной с массивом байт за пределы функции где эта переменная используется. [Код до](https://gist.github.com/Drovosek01/9d47068365ea0bce26526ee61b23be7c?permalink_comment_id=5141498#gistcomment-5141498) и [код после](https://gist.github.com/Drovosek01/9d47068365ea0bce26526ee61b23be7c?permalink_comment_id=5141499#gistcomment-5141499). И просто при выносе массива байт за пределы переменной скрипт стал работать в 3 раза медленнее. Это очень странно.
- Нет "нативного" пути (я не нашел такой) переместить файл в Корзину.
  - Чтобы переместить файл в Корзину - необходимо будет использовать компоненты из Visual Basic Script или JScript.
- Нет способа (я не нашел) проверить нужны ли права администратора для удаления папки [без попытки ее удаления](https://qna.habr.com/q/1364540)
- Блок `catch {}` после `try {}` ловит не все ошибки
  - Например если при выполнении `New-Item` или `Remove-Item` будет ошибка, то без аргумента `-ErrorAction Stop` блок `catch {}` не поймает ошибку

## Полезности

### Репозитории с примерами грамотных скриптов

Скрипты на Powershell
- https://github.com/KurtDeGreeff/PlayPowershell

Скрипты на CMD/Bat
- https://github.com/npocmaka/batch.scripts
- https://github.com/corpnewt/ProperTree/blob/master/ProperTree.bat

## Ответы на возможные вопросы

1. Почему нет функционала замены байт с указанием смещения?
    - Замену байт по конкретным смещениям/оффсетам удобно выполнять вручную и только если таких адресов для замены не много. Обычно нужно менять несколько наборов байт и зачастую эти наборы идут группами. Указывать смещение и какой байт нужно поместить в смещение - долго даже в шаблоне, но если хотите добавить такую реализацию вот [пример](https://stackoverflow.com/a/20935550)
    - Замена по паттернам байт более универсальна потому что так выше вероятность, что после обновления бинарника паттерн для поиска+замены будет прежний, в отличии от того, что адреса/оффсеты для замены байт будут прежними
    - Мне не приходилось в своей практике использовать поиск+замену байт по конкретным адресам. Мне удобнее шаблоны.
2. Почему так много кода?
    - У меня не много опыта в написании кода. А код на Powershell и CMD я пишу впервые
    - Я старался сделать проект монолитным, чтобы на компьютер на котором необходимо выполнять модификации можно было перенести всего пару файлов, включая шаблон и просто запустить "исполняемый файл" двойным кликом
    - Я старался добавлять разнообразные проверки (например на существование пути к файлу или на то) везде где считал нужным, а это много где. Вероятно не везде нужны эти проверки. Особенно если продумать архитектуру проекта и привести ее в нормальный вид.
    - У меня было желание, (хотя, скорее всего, это личный спортивный интерес) сделать так, чтобы скрипт можно было запускать и выполнять без прав администратора и эти права запрашивались только тогда, когда они нужны. Из-за этого пришлось добавлять и обрабатывать проверки нужны ли права администратора для данной операции и запускать отдельный Powershell-код (в том числе многострочный) в отдельных процессах с запросом прав администратора. Если убрать все эти проверки и проверять наличие прав только в самом начале - код похудеет на 1/5 часть, наверное.
3. Почему шаблон не в формате JSON или XML?
    - Потому что эти типы структур файлов имеют довольно строгий формат разметки и при заполнении файла вручную, писать и форматировать текст в структуре JSON или XML было бы сложно. Я делал структуру шаблона такой, которая прощает ошибки и менее строгая, в отличии от JSON и XML.
4. Как помочь проекту?
    - Выполнить то, что написано в TODO (не ухудшив функциональность и производительность кода)
    - Провести рефакторинг и улучшение производительности кода/утилиты
    - Или найти того кто это сделает