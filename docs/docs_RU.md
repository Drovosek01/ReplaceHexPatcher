# ReplaceHexPatcher - Документация

Language: Русский | [English](docs.md)

## Предисловие

Изначально я преследовал цель создать 2х-кликовое нативное для Windows решение для поиска и замены байт как это умеют делать утилиты `perl` и `sed` в macOS и GNU Linux.

То есть для решения поставленной задачи (поиска и замены байт) необходимо использовать только то что есть в Windows сразу после установки. Никаких сторонних файлов/программ скачиваться и применяться не должно.

В Windows предустановлены 3 "инструмента программирования" - CMD, Visual Basic Script, Powershell.
CMD слишком ограничен в возможностях. В Visual Basic Script я не нашел способа написать эффективный код для поиска и замены шаблона байт в файле любого объема. А вот Powershell это, очень грубо говоря, среда выполнения кода C#, а с помощью C# можно делать очень многие вещи и поэтому с помощью кода на Powershell вполне можно выполнить поиск и замену байт в hex формате.

Я начал искать способы сделать это на Powershell и сначала нашел [этот](https://stackoverflow.com/a/57339359) пример, но, если я правильно помню, такой поиск и замена байт работали у меня медленно. Других примеров я не смог найти и обратился к ChatGPT и он сгенерировал для меня необходимый скрипт. Я его протестировал и улучшил и написал дополнительные скрипты-обертки.

Конечно интерпретируемый код работает медленнее чем скомпилированные утилиты для данных задач, но, возможно если такие утилиты написанные на C# ([HexAndReplace](https://github.com/jjxtra/HexAndReplace) или [BinaryFilePatcher](https://github.com/Invertex/BinaryFilePatcher)) переписать на Powershell то это улучшит код и скорость его выполнения (но это не точно)

## Основа (Core)

Основу (ядро) данного инструмента составляет скрипт [ReplaceHexBytesAll.ps1](../core/ReplaceHexBytesAll.ps1) на Powershell, который находится в папке core. Он как раз и выполняет функцию поиска + замены байт и вывода небольшого отчета о том все ли шаблоны были заменены или какие-то шаблоны не найдены.

Он принимает 2 аргумента:
1. Путь к файлу в котором необходимо выполнить поиск и замену байт
2. Hex-шаблоны для поиска и замены байт в виде массива или 1 строкой

С путем к файлу все понятно, а вот шаблоны hex-байт можно предоставить в нескольких видах. В данном случае шаблон это строка разделенная 1 символом (`/` или `\` или `|`) на 2 части и первая часть это hex-байты для поиска, а вторая часть это hex-байты для замены.

Hex-байты можно передавать в разном формате - `AABBCC` или `A ABB CC` или `\xAAB BCC 1d` или `aabbcc`. В общем наличие или отсутствие пробелов, а также наличие или отсутствие символа `\x` (который обозначает 16-битное значение), а также регистр букв - не важны. Это все очистится и преобразуется к 1 формату.
Важно только чтобы паттерны содержали hex-символы (то есть все цифры `0-9` и буквы `a-f` включительно и без учета регистра).

Hex-шаблоны можно передавать как массив строк, так и в виде строки в которой содержится массив. 

Например вот так передается массив строк:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns "AABBCC/112233","44aa55\66bb77","1234|5678","E8A62600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"
```
А вот так передается строка с массивом
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns '"AABBCC/112233","44aa55\66bb77","1234|5678","E8A62600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"'
```
И потом это все распознается внутри скрипта и преобразуется в массив. Так сделано и для удобства и для возможности передачи шаблонов байт из другого Powershell-скрипта.

Попытки написать обертки над основным скриптом показали, что если из другого Powershell-скрипта запускать данный Powershell-скрипт от имени администратора то передавать аргументы в качестве массива не получится, поэтому пришлось делать дополнительную логику по обработке строки.

## Обертки (Wrappers)

Основной скрипт выполняет только поиск и замену байт в 1 файле. А что если необходимо сделать это для нескольких файлов?

Тогда поможет другой скрипт который будет выполнять основной скрипт передавая ему необходимые заранее сформированные аргументы - путь к файлу и необходимый массив паттернов, а также выполнять другие побочные эффекты:
- проверить наличие скрипта локально или скачать его по заготовленной ссылке
- проверять существование файлов которые необходимо модифицировать 
- завершать работу файла, который необходимо пропатчить, если он выполняется
- добавление строк в файл hosts (и проверка наличия этих строк, если они ранее были добавлены)
- блокировка `.exe` с помощью Windows Firewall
- создание файлов с заготовленным текстом
- удаление файлов и папок

и т.д.

Есть 2 типа скриптов-оберток:
1. Данные внутри скрипта (data inside)
2. Данные из шаблона (data in template)

### Обертка "data inside"

В первом типе скрипта все необходимые - пути или ссылки на "ядро", пути к файлам-целям для модификаций, все паттерны для поиска и замены, текст для hosts и для других файлов - все это находится внутри скрипта.

Для удобства внутрь скрипта добавлен чек-лист того что нужно проверить перед тем как считать его готовым.

1. Файлы-цели для патча
    - Если необходимо пропатчить несколько файлов (файлов-целей), то необходимо в переменную `count_target_files` вписать количество файлов для патча
    - Путь к каждому файлу поместить в переменные `target_path_1` и последняя цифра переменной должна быть уникальным последовательным индексом
2. Патчи - паттерны для поика+замены байт для файлов-целей
    - В переменную `count_patches_f1` необходимо вписать количество паттернов для поиска+замены байт. Последняя цифра в переменной означает индекс файла-цели для которого необходимо применить паттерны. Если файлов-целей несколько, то необходимо создать несколько таких переменных изменив индексы в их название на индексы соответствующие файлам-целям
    - Создать переменные `original_f1_1` и `patched_f1_1` в которых необходимо хранить hex-паттерны для поиска и замены байт соответственно. Для 1 hex-паттерна 1 переменная и если паттернов несколько - в новых переменных увеличить последнее число-индекс на 1. Текст `f1` означает индекс файла для которого предназначается паттерн
    - TODO: возможно лучше переделать скрипт, чтобы паттерны поиска+замены записывать не в разные переменные, а в 1 переменную, например `"pattern_f1_1=AABBCC/112233"`
3. Создание текстовых файлов
    - Если текстовые файлы создавать не нужно - закомментировать строку `call :create_all_text_files`
    - Если необходимо создать только 1 текстовый файл, то
      - в переменную `file_text_path_1` - поместить полный путь к текстовому файлу
      - в переменную `endline_text_file_1` вписать тип окончания строки (CRLF или LF)
      - в переменную `create_mode_text_file_1` вписать "режим создания" файла - FORCE или NOTOVERWRITE. При режиме FORCE файл будет перезаписан если такой файл существует, а при режиме NOTOVERWRITE файл не будет затронут/перезаписан, если он уже существует
      - внутри функции `:create_text_file_1` вписать текст который необходимо поместить в файл
    - Если необходимо создать несколько текстовых файлов, то создать несколько вышеперечисленных переменных под каждый файл и увеличить число-индекс в конце переменной
      - А также для каждого файла создать функцию `:create_text_file_1` с индивидуальным текстом для содержания файла (ну и число-индекс в названии функции тоже увеличить)
4. Добавление строк в hosts
    - Если в файл hosts ничего не нужно добавлять - закомментировать строку `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"`
    - Если в файл hosts нужно добавить какие-то строки, то сами URL-адреса для блокировки добавить внутрь функции `:block_hosts`, при выполнении скрипта функция сама сформирует строки и добавит их в hosts, если таких строк раньше не было
      - Также в строку вызова функции `call :block_hosts "NOTOVERWRITE" "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS"` первым аргументом добавить слово "FORCE" или "NOTOVERWRITE". "FORCE" означает тупо добавить строки в конец hosts, а "NOTOVERWRITE" означает не добавлять их если точно такой же набор строк с таким же названием группы есть в конце файла
      - Ну а вместо "WRITE HERE NAME OF GROUP FILES ADDED TO HOSTS" написать название/заголовок для группы строк, например "Adobe servers"
5. Блокировка файлов-целей с помощью Windows Firewall
    - Если файлы-цели не нужно блокировать с помощью фаервола, то закомментировать строку `call :block_targets_with_firewall`, иначе оставить эту строку без изменений

Возможно было бы логичнее часть функционала вынести в отдельные файлы-скрипты, но я хотел сделать максимально "монолитное" 2-кликовое решение. 


### Обертка "data in template"

Во втором типе скрипта все данные для работы берутся из файла `template.txt`

Структура шаблона была сделана так, чтобы данные можно было легко заполнять вручную обычным Ctrl+C и Ctrl+V, поэтому шаблоны данных в формате `.json` и `.xml` не подходят, потому что при их заполнении легко ошибиться и нарушить структуру.

#### Структура шаблона

1. Комментарии
    - В файле-шаблоне могу быть строки с комментариями. Все строки содержащие символ один из этих символов `;`, `::`, `#` - считаются комментариями и будут удалены перед дальнейшим анализом
2. Глобальные переменные
    - Текст `$USER` будет заменен на имя текущего пользователя Windows везде в шаблоне
3. Блоки с строками/данными
   1. В шаблоне могут располагаться разные данные и каждый тип данных должен располагаться в своей секции. Секции отделяются строками, которые содержат следующий текст
       - `[start-НАЗВАНИЕ_СЕКЦИИ]` - строка начало секции
       - `[end-НАЗВАНИЕ_СЕКЦИИ]` - строка конец секции
       - все что между этими строками - данные секции и будут анализироваться парсером в зависимости от названия секции
   2. Названия секций
       - `patcher_path_or_url` - секция в которой располагаются строки с путями к файлу-патчеру (основной/core файл) или строки URL для его скачивания. Будет выбрана первая строка по которой файл будет существовать или скачается без проблем
       - `variables`
       - `targets_and_patterns`
       - `file_create_from_text`
       - `file_create_from_base64`
       - `hosts_add`
       - `files_or_folders_delete`
       - `firewall_block`

## Небольшие личные выводы

Это мой первый опыт написания скриптов на CMD (batch) и Powershell. Учитывайте это при чтении моих выводов.

### О CMD

**CMD это боль!**

И вот почему:
- нет нормальных функций
  - конструкции `call` необходимо обязательно помещать в конце файла, иначе при выполнении кода эти блоки также будут прочитаны и выполнены, они никак не огорожены, просто на них есть "ссылка" 
- нет нормальных циклов
  - чтобы сделать циклы необходимо делать условия в которых есть `goto` на метку вне/перед условием
- повторное оборачивание чего-либо в кавычки - добавляет эти кавычки в оборачиваемое значение и из-за этого часто возникают проблемы и это приходится держать в голове
- нет нормального способа хранить любой многострочный текст
  - если в многострочном тексте нет кавычек и некоторых спец. символов, то такой текст можно хранить в многострочном виде, но если есть кавычки и спец. символы то приходится перед каждой строкой добавлять `echo `

Основной плюс из-за которого стоит рассматривать написание чего-либо на CMD - это то, что его можно запустить 2-м кликом в любой Windows. (Конечно есть еще VBS но он как-то менее распространен)

### Адаптивный перезапуск с правами админа (UAC) - это очень большой геморрой

Если делать утилиту "по феншую", то права администратора необходимо запрашивать только когда без них точно не обойтись.

Также стоит помнить про атрибут "только для чтения", потому что если у файла стандартные права то этот атрибут можно снять без проблем без запроса прав администратора, хотя тест на попытку записи покажет что нужны права админа для изменения файла.

Жонглирование этими 2мя пунктами "права администратора" и атрибут "только для чтения" довольно запутанная задача и это добавляет довольно много дополнительной логики в скрипт и уменьшает читаемость кода.

Особенно это является проблемой когда из обычного Powershell-скрипта необходимо запустить код который содержит многострочный текст.

Намного проще и удобнее запросить права администратора в самом начале выполнения скрипта и прервать выполнение при их отсутствие, но не факт что эти права действительно необходимы для внесения изменений.

True-путь это запрашивать права при необходимости.

### О Powershell

Powershell показал себя с хорошей стороны и является хорошей альтернативой Unix Shell.

Естественно, сравнивать CMD и Powershell это тупо, это совсем разные "уровни", это как сравнивать небо и землю.

Но без недостатков не обошлось. И вот какие они:
- `.ps1` скрипты нельзя запустить двойным кликом, в отличие от Unix Shell-скриптов в Unix-системах и в отличие от `.cmd` или `.bat` или `.vbs` файлов в Windows. Придется писать скрипт-обертку `.cmd` для запуска `.ps1`, если нужен запуск по двойному клику.
- Типизация фиктивная - интерпретатор нигде не проверяет соответствие переменной указанному ей типу. Похоже типизация применяется только в IDE для авто дополнения.
- Нет хороших IDE (я не нашел).
  - Windows Powershell ISE - выглядит старомодно и топорно и лично мне в ней не комфортно писать большой код и нет множества удобных функций, по сравнению с Visual Studio Code.
  - Visual Studio Code по началу казалась безупречной альтернативой "ISE" для написания кода Powershell, но в VSC почему-то авто дополнение работает странно (или не работает совсем) в некоторых моментах - когда начинаю набирать слова `break` или `continue` то автодополнение не подсказывает продолжение этих слов, значит есть и другие аналогичные ситуации.
  - Может в IDE от JetBrains все идеально при написании кода на Powershell, но я это не проверял.
- Возврат значения в "никуда" в самом скрипте - вернет значение в поток вывода.
  - Это немного странное поведение и если о нем не знать или забыть учесть этот нюанс - можно потратить много времени на дебаг. А именно при выполнении функций `New-Item` и функции `.Add()` у `ArrayList` - эти функции возвращают значение. Если [не присвоить](https://stackoverflow.com/a/46586504) то значение - оно попадет в поток вывода, то есть смешается с тем что будет передаваться в `Write-Host`.
- Есть странная ситуация при которой производительность скрипта падает в 3 раза (он работает в 3 раза дольше)
  - Я пытался отрефакторить одну функцию и вынес инициализацию переменной с массивом байт за пределы функции где эта переменная используется. [Код до](https://gist.github.com/Drovosek01/9d47068365ea0bce26526ee61b23be7c?permalink_comment_id=5141498#gistcomment-5141498) и [код после](https://gist.github.com/Drovosek01/9d47068365ea0bce26526ee61b23be7c?permalink_comment_id=5141499#gistcomment-5141499). И просто при выносе массива байт за пределы переменной скрипт стал работать в 3 раза медленнее. Это очень странно.
- Нет "нативного" пути (я не нашел такой) переместить файл в Корзину.
  - Чтобы переместить файл в Корзину - необходимо будет использовать компоненты из Visual Basic Script или JScript.
- Нет способа (я не нашел) проверить нужны ли права администратора для удаления папки [без попытки ее удаления](https://qna.habr.com/q/1364540)
- Блок `catch {}` после `try {}` ловит не все ошибки
  - Например если при выполнении `New-Item` или `Remove-Item` будет ошибка, то без аргумента `-ErrorAction Stop` блок `catch {}` не поймает ошибку

## Полезности

### Репозитории с примерами грамотных скриптов

Скрипты на Powershell
- https://github.com/KurtDeGreeff/PlayPowershell

Скрипты на CMD/Bat
- https://github.com/npocmaka/batch.scripts
- https://github.com/corpnewt/ProperTree/blob/master/ProperTree.bat