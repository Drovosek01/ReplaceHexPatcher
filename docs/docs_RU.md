# ReplaceHexPatcher - Документация

Language: Русский | [English](docs.md)

## Предисловие

Изначально я преследовал цель создать 2х-кликовое нативное для Windows решение для поиска и замены байт как это умеют делать утилиты `perl` и `sed` в macOS и GNU Linux.

То есть для решения поставленной задачи (поиска и замены байт) необходимо использовать только то что есть в Windows сразу после установки. Никаких сторонних файлов/программ скачиваться и применяться не должно.

В Windows предустановлены 3 "инструмента программирования" - CMD, Visual Basic Script, Powershell.
CMD слишком ограничен в возможностях. В Visual Basic Script я не нашел способа написать эффективный код для поиска и замены шаблона байт в файле любого объема. А вот Powershell это, очень грубо говоря, среда выполнения кода C#, а с помощью C# можно делать очень многие вещи и поэтому с помощью кода на Powershell вполне можно выполнить поиск и замену байт в hex формате.

Я начал искать способы сделать это на Powershell и сначала нашел [этот](https://stackoverflow.com/a/57339359) пример, но, если я правильно помню, такой поиск и замена байт работали у меня медленно. Других примеров я не смог найти и обратился к ChatGPT и он сгенерировал для меня необходимый скрипт. Я его протестировал и улучшил и написал дополнительные скрипты-обертки.

Конечно интерпретируемый код работает медленнее чем скомпилированные утилиты для данных задач, но, возможно если такие утилиты написанные на C# ([HexAndReplace](https://github.com/jjxtra/HexAndReplace) или [BinaryFilePatcher](https://github.com/Invertex/BinaryFilePatcher)) переписать на Powershell то это улучшит код и скорость его выполнения (но это не точно)

## Основа (Core)

Основу (ядро) данного инструмента составляет скрипт [ReplaceHexBytesAll.ps1](../core/ReplaceHexBytesAll.ps1) на Powershell, который находится в папке core. Он как раз и выполняет функцию поиска + замены байт и вывода небольшого отчета о том все ли шаблоны были заменены или какие-то шаблоны не найдены.

Он принимает 2 аргумента:
1. Путь к файлу в котором необходимо выполнить поиск и замену байт
2. Hex-шаблоны для поиска и замены байт в виде массива или 1 строкой

С путем к файлу все понятно, а вот шаблоны hex-байт можно предоставить в нескольких видах. В данном случае шаблон это строка разделенная 1 символом (`/` или `\` или `|`) на 2 части и первая часть это hex-байты для поиска, а вторая часть это hex-байты для замены.

Hex-байты можно передавать в разном формате - `AABBCC` или `A ABB CC` или `\xAAB BCC 1d` или `aabbcc`. В общем наличие или отсутствие пробелов, а также наличие или отсутствие символа `\x` (который обозначает 16-битное значение), а также регистр букв - не важны. Это все очистится и преобразуется к 1 формату.
Важно только чтобы паттерны содержали hex-символы (то есть все цифры `0-9` и буквы `a-f` включительно и без учета регистра).

Hex-шаблоны можно передавать как массив строк, так и в виде строки в которой содержится массив. 

Например вот так передается массив строк:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns "AABBCC/112233","44aa55\66bb77","1234|5678","E8A62600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"
```
А вот так передается строка с массивом
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\test\test.exe" -patterns '"AABBCC/112233","44aa55\66bb77","1234|5678","E8A62600000FB6D8488D4C2440FF1578/EB032600000FB6D8488D4C2440FF1578"'
```
И потом это все распознается внутри скрипта и преобразуется в массив. Так сделано и для удобства и для возможности передачи шаблонов байт из другого Powershell-скрипта.

Попытки написать обертки над основным скриптом показали, что если из другого Powershell-скрипта запускать данный Powershell-скрипт от имени администратора то передавать аргументы в качестве массива не получится, поэтому пришлось делать дополнительную логику по обработке строки.

## Обертки (Wrappers)

Основной скрипт выполняет только поиск и замену байт в 1 файле. А что если необходимо сделать это для нескольких файлов?

Тогда поможет другой скрипт который будет выполнять основной скрипт передавая ему необходимые заранее сформированные аргументы - путь к файлу и необходимый массив паттернов, а также выполнять другие побочные эффекты:
- проверить наличие скрипта локально или скачать его по заготовленной ссылке
- проверять существование файлов которые необходимо модифицировать 
- завершать работу файла, который необходимо пропатчить, если он выполняется
- добавление строк в файл hosts (и проверка наличия этих строк, если они ранее были добавлены)
- блокировка `.exe` с помощью Windows Firewall
- создание файлов с заготовленным текстом
- удаление файлов и папок

и т.д.

Есть 2 типа скриптов-оберток:
1. Данные внутри скрипта (data inside)
2. Данные из шаблона (data in template)

### Обертка "data inside"

В первом типе скрипта все необходимые - пути или ссылки на "ядро", пути к файлам-целям для модификаций, все паттерны для поиска и замены, текст для hosts и для других файлов - все это находится внутри скрипта.

### Обертка "data in template"

Во втором типе скрипта все данные для работы берутся из файла `template.txt`