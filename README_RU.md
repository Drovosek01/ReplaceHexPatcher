# Replace Hex native for Windows

Language: Русский | [English](README.md)


## Что это за репозиторий

Код в этом репозитории это результат попытки найти нативный для Windows способ для поиска и замены байт.

Нативный - значит он без использования сторонних программ (только средствами идущими в комплекте с системой, в данном случае Windows 10).

В UNIX-системах поиск и замену байт в hex формате можно осуществить с помощью утилит `perl` и `sed` (и, наверное, каких-то еще инструментов) которые предустановлены в большинство GNU Linux дистрибутивов и в macOS тоже.

В Windows предустановлены 3 "инструмента программирования" - CMD, Visual Basic Script, Powershell.
CMD слишком ограничен в возможностях. В Visual Basic Script я не нашел способа написать эффективный код для поиска и замены шаблона байт в файле любого объема. А вот Powershell это, очень грубо говоря, среда выполнения кода C#, а с помощью C# можно делать очень многие вещи и поэтому с помощью кода на Powershell вполне можно выполнить поиск и замену байт в hex формате.

## Альтернативы

Я не нашел других готовых к использованию скриптов на Powershell или Visual Basic Script для поиска замены байт.
В данном случае альтернативный вариант - не нативный способ:

- sed можно скачать в (и входит в состав):
    - [sed-windows](https://github.com/mbuilov/sed-windows)
    - [sed for Windows](https://gnuwin32.sourceforge.net/packages/sed.htm) (GNU for Win32) + [Sourceforge files](https://sourceforge.net/projects/gnuwin32/files/sed/)
    - [Git for Windows](https://git-scm.com/download/win) или [сайт 2](https://gitforwindows.org/) и использовать `perl` и `sed` которые есть в Git Bash
    - [Cygwin](https://cygwin.com/)
    - [msysgit](https://github.com/msysgit/msysgit/) или [msys2](https://www.msys2.org/)
    - [GNU utilities for Win32](https://unxutils.sourceforge.net/)
    - [sed by Eric Pement](https://www.pement.org/sed/)
- [HexAndReplace](https://github.com/jjxtra/HexAndReplace)
- [BinaryFilePatcher](https://github.com/Invertex/BinaryFilePatcher)
- [BBE for Windows](https://anilech.blogspot.com/2016/09/binary-block-editor-bbe-for-windows.html)

## Функции

Основная:
- Поиск и замена всех найденных последовательностей байт
- Создание бэкапов файлов в случае нахождения hex-паттернов
- Несколько возможных форматов передаваемых hex-значений
- Запрашивает права администратора только если это необходимо

Вместе с обертками:
- Замена байт в нескольких файлах
- Удаление файлов и папок
- Добавление строк в файл `hosts`
- Удаление конкретного текста и адресов из файла `hosts`
- Блокировка файлов в Windows Firewall
- Удаление всех правил для конкретных файлов из Windows Firewall
- Работа с файлом-шаблоном с заготовленными паттернами
  - Использование переменных в шаблоне
  - Создание новых текстовых файлов на основе текста
  - Создание новых текстовых файлов на основе base64
  - Создание новых бинарных файлов на основе base64
  - Применение строк для модификации реестра
  - Выполнение кода Powershell из шаблона
  - Выполнение кода CMD из шаблона

Больше информации смотрите в [документации](./docs/docs_RU.md)

## Примеры использования

### Основной скрипт-патчер

```
.\ReplaceHexBytesAll.ps1 -filePath "<путь к файлу>" -patterns "<hex-паттерн поиска>/<hex-паттерн замены>",
```
- `hex-паттерн` не имеет строгого формата.
  - Между значениями в паттерне может быть любое количество пробелов и символов - все они удалятся (их наличие не вызовет ошибок)
- разделитель между паттернами поиска и замены может быть одним из символов `/`,`\`,`|`
- в параметр `-patterns` можно передать как массив паттернов в виде строк разделенных запятой, так и 1 строку в которой наборы паттернов разделены запятой
- можно передать параметр `-makeBackup` и тогда оригинальный файл будет сохранен с добавленным расширением `.bak`

Вот пример:

1. Запустить Powershell
2. С помощью `cd <путь>` перейти в папку с файлом `ReplaceHexBytesAll.ps1`
3. В окне Powershell выполнить:
```
.\ReplaceHexBytesAll.ps1 -filePath "D:\TEMP\file.exe" -patterns "48 83EC2 8BA2F 000000 488A/202 0EB1 1111 11111 111111","C42518488D4D68\90909011111175","45A8488D55A8|75EB88909090","\xAA\x7F\xBB\x08\xE3\x4D|\xBB\x90\xB1\xE8\x99\x4D" -makeBackup
```

### Скрипт-обертка с всеми данными внутри

В папке `wrappers` находится папка `data inside` и в ней файл `Start.cmd`
Заполните все данные внутри файла `Start.cmd` и можно будет запустить его двойным кликом.
Внутри файла находится памятка того что необходимо сделать/заполнить внутри файла, также об это подробнее написано в [документации](./docs/docs_RU.md)

### Скрипт-обертка с обработкой данных из template.txt

В папке `wrappers` находится папка `data inside` и в ней файлы `Start.cmd`, `Parser.ps1`, `template.txt`

Необходимо:
1. Заполнить `template.txt` в зависимости от того, что вам необходимо сделать
2. Если все 3 файла находятся в 1 папке - просто запустить `Start.cmd`
3. Если все файлы находятся по отдельности - в `Start.cmd` заполнить пути к ним или URL-ссылки на их скачивание и запустить двойным кликом
4. Либо через Powershell напрямую запустить `Parser.ps1` и передать ему путь или ссылку на шаблон в качестве аргумента:
```
\.Parser.ps1 -templatePath "D:\путь к\template.txt"
```
также вторым аргументом можно передать путь к скрипту-патчеру `-patcherPath "C:\путь к\ReplaceHexBytesAll.ps1"` и он будет приоритетней тех, которые указаны в шаблоне template


## Документация

В отдельном [файле](./docs/docs_RU.md)

## ToDo

- [ ] Сделать поддержку ограничения замен найденных шаблонов (если нужно заменять не все найденные последовательности)
- [ ] Сделать поддержку вопросительных знаков `??` в шаблонах как в [AutoIt](https://www.autoitscript.com/autoit3/docs/functions/StringRegExp.htm)
- [ ] Сделать поддержку регулярных выражений в hex-шаблонах как в `sed` или `perl`
  - Возможно [этот](https://stackoverflow.com/a/55314611) пример поможет
- [ ] Сделать функцию поиска начиная с определенного смещения в файле или начиная с определенной части файла в %
- [ ] Сделать считывание паттернов из файла
- [ ] Отрефакторить функцию `SearchAndReplace-HexPatternInBinaryFile` в основном скрипте
  - Функция большая и выглядит так как будто половина логики функции должна находится в другой функции, но при попытке передать массив байт `$fileBytes` за пределы функции или объявить массив за пределами этой функции - скорость работы ухудшается в 3 раза. Я пока не знаю почему так и как.
- [ ] Сделать проверку наличия необходимых прав сразу после первого найденного паттерна, а не после перебора всех паттернов в основном скрипте
- [ ] Добавить поддержку [глоббинга](https://stackoverflow.com/questions/30229465/what-is-file-globbing) в строки с путями к файлам/папкам, которые необходимо найти, в файле-шаблоне
- [ ] Возможно стоит добавить логику запуска `.ps1` файлов от имени администратора в скрипте-парсере
- [ ] Найти нормальный способ проверить нужны ли права администратора для удаления папки
  - Текущий способ проверяет это путем создания и удаления пустого файла в необходимой папке (это неправильно с точки зрения логики и производительности, но в большинстве ситуаций это работает как надо)
- [ ] Стилизовать прогресс-бары
  - При поиске Firewall-правил с указанными путями к exe - появляется прогресс бар отображающий прогресс выполнения процесса. Он появляется в верху терминала просто с названием метода `Get-NetFirewallRule`
- [ ] Добавить какой-то способ выставить очередность выполнения для секций в шаблоне
  - Могут быть ситуации, когда кастомный Powershell-код или CMD-код из шаблона нужно выполнить первым, например что-то сделать с сервисами (удалить или перезапустить или что-то еще)

## Системные требования

Весь код был написан и протестирован в Windows 10 x64 22H2.

Я не проверял совместимость кода и использованных функций Powershell с предыдущими версиями. Вероятно для их выполнения понадобится Powershell 5.1 который идет в комплекте с Windows 10.

Если вы работаете на Windows 7, 8, 8.1 то, вероятно, вам необходимо будет установить [Microsoft .NET Framework 4.8](https://support.microsoft.com/topic/microsoft-net-framework-4-8-offline-installer-for-windows-9d23f658-3b97-68ab-d013-aa3c3e7495e0) и [Powershell 5.1](https://www.microsoft.com/download/details.aspx/?id=54616) чтобы код из этого репозитория у вас работал.